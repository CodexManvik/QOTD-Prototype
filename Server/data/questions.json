[
    {
        "id": "qotd-001",
        "date": "2026-01-31",
        "title": "Two Sum",
        "difficulty": "Easy",
        "problemStatement": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
        "sampleInput": "nums = [2,7,11,15], target = 9",
        "sampleOutput": "[0,1]",
        "expectedOutput": "0,1",
        "solution": "class Solution: def twoSum(self, nums, target): h = {}; for i, num in enumerate(nums): n = target - num; if n in h: return [h[n], i]; h[num] = i",
        "hints": [
            "Try using a hash map to store visited numbers.",
            "The time complexity should be O(n)."
        ]
    },
    {
        "id": "qotd-002",
        "date": "2026-02-01",
        "title": "Reverse String",
        "difficulty": "Easy",
        "problemStatement": "Write a function that reverses a string. The input string is given as an array of characters s.",
        "sampleInput": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
        "sampleOutput": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
        "expectedOutput": "o,l,l,e,h",
        "solution": "class Solution: def reverseString(self, s): s.reverse()",
        "hints": [
            "Consider using two pointers, one at the start and one at the end.",
            "Swap characters until the pointers meet."
        ]
    },
    {
        "id": "qotd-003",
        "date": "2026-02-02",
        "title": "Valid Parentheses",
        "difficulty": "Easy",
        "problemStatement": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
        "sampleInput": "s = \"()[]{}\"",
        "sampleOutput": "true",
        "expectedOutput": "true",
        "solution": "class Solution: def isValid(self, s): stack = []; m = {')':'(', '}':'{', ']':'['}; for c in s: if c in m: if not stack or stack.pop() != m[c]: return False else: stack.append(c); return not stack",
        "hints": [
            "Use a stack to keep track of opening brackets.",
            "When you encounter a closing bracket, check if it matches the top of the stack."
        ]
    },
    {
        "id": "qotd-004",
        "date": "2026-02-03",
        "title": "Container With Most Water",
        "difficulty": "Medium",
        "problemStatement": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water.",
        "sampleInput": "height = [1,8,6,2,5,4,8,3,7]",
        "sampleOutput": "49",
        "expectedOutput": "49",
        "solution": "class Solution: def maxArea(self, height): l, r = 0, len(height) - 1; ans = 0; while l < r: ans = max(ans, min(height[l], height[r]) * (r - l)); if height[l] < height[r]: l += 1; else: r -= 1; return ans",
        "hints": [
            "Try the two-pointer approach.",
            "Start with the maximum width and move the pointer with the smaller height inward."
        ]
    },
    {
        "id": "qotd-005",
        "date": "2026-02-04",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "problemStatement": "Given a string s, find the length of the longest substring without repeating characters.",
        "sampleInput": "s = \"abcabcbb\"",
        "sampleOutput": "3",
        "expectedOutput": "3",
        "solution": "class Solution: def lengthOfLongestSubstring(self, s): m = {}; l = 0; ans = 0; for r, c in enumerate(s): if c in m: l = max(l, m[c] + 1); m[c] = r; ans = max(ans, r - l + 1); return ans",
        "hints": [
            "Use a sliding window approach.",
            "Keep a set or map of characters in the current window."
        ]
    },
    {
        "id": "qotd-006",
        "date": "2026-02-05",
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "problemStatement": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
        "sampleInput": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "sampleOutput": "6",
        "expectedOutput": "6",
        "solution": "class Solution: def trap(self, height): l, r = 0, len(height) - 1; l_max, r_max = 0, 0; ans = 0; while l < r: if height[l] < height[r]: if height[l] >= l_max: l_max = height[l] else: ans += l_max - height[l]; l += 1; else: if height[r] >= r_max: r_max = height[r] else: ans += r_max - height[r]; r -= 1; return ans",
        "hints": [
            "Compute the maximum height to the left and right of each index.",
            "The water level at 'i' is min(left_max[i], right_max[i]) - height[i]."
        ]
    },
    {
        "id": "qotd-007",
        "date": "2026-02-06",
        "title": "Merge k Sorted Lists",
        "difficulty": "Hard",
        "problemStatement": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
        "sampleInput": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "sampleOutput": "[1,1,2,3,4,4,5,6]",
        "expectedOutput": "1,1,2,3,4,4,5,6",
        "solution": "# Use a min-heap to efficiently merge k sorted lists",
        "hints": [
            "Consider using a Min-Heap (Priority Queue).",
            "Add the head of each list to the heap, then extract the minimum and add its next node."
        ]
    },
    {
        "id": "qotd-008",
        "date": "2026-02-07",
        "title": "Palindrome Number",
        "difficulty": "Easy",
        "problemStatement": "Given an integer x, return true if x is a palindrome, and false otherwise. An integer is a palindrome when it reads the same forward and backward.",
        "sampleInput": "x = 121",
        "sampleOutput": "true",
        "expectedOutput": "true",
        "solution": "class Solution: def isPalindrome(self, x): if x < 0: return False; s = str(x); return s == s[::-1]",
        "hints": [
            "Negative numbers are never palindromes.",
            "You can convert to string and compare, or reverse half the number mathematically."
        ]
    },
    {
        "id": "qotd-009",
        "date": "2026-02-08",
        "title": "Maximum Subarray",
        "difficulty": "Medium",
        "problemStatement": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
        "sampleInput": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "sampleOutput": "6",
        "expectedOutput": "6",
        "solution": "class Solution: def maxSubArray(self, nums): max_sum = curr_sum = nums[0]; for n in nums[1:]: curr_sum = max(n, curr_sum + n); max_sum = max(max_sum, curr_sum); return max_sum",
        "hints": [
            "Use Kadane's algorithm.",
            "At each position, decide whether to extend the current subarray or start a new one."
        ]
    },
    {
        "id": "qotd-010",
        "date": "2026-02-09",
        "title": "Climbing Stairs",
        "difficulty": "Easy",
        "problemStatement": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
        "sampleInput": "n = 3",
        "sampleOutput": "3",
        "expectedOutput": "3",
        "solution": "class Solution: def climbStairs(self, n): if n <= 2: return n; a, b = 1, 2; for _ in range(3, n+1): a, b = b, a+b; return b",
        "hints": [
            "This is a classic dynamic programming problem.",
            "The number of ways to reach step n is the sum of ways to reach step n-1 and n-2."
        ]
    },
    {
        "id": "qotd-011",
        "date": "2026-02-10",
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction.",
        "sampleInput": "prices = [7,1,5,3,6,4]",
        "sampleOutput": "5",
        "expectedOutput": "5",
        "solution": "class Solution: def maxProfit(self, prices): min_price = float('inf'); max_profit = 0; for p in prices: min_price = min(min_price, p); max_profit = max(max_profit, p - min_price); return max_profit",
        "hints": [
            "Track the minimum price seen so far.",
            "Calculate the profit if you sell at the current price."
        ]
    },
    {
        "id": "qotd-012",
        "date": "2026-02-11",
        "title": "Binary Tree Inorder Traversal",
        "difficulty": "Easy",
        "problemStatement": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
        "sampleInput": "root = [1,null,2,3]",
        "sampleOutput": "[1,3,2]",
        "expectedOutput": "1,3,2",
        "solution": "class Solution: def inorderTraversal(self, root): res = []; def dfs(node): if not node: return; dfs(node.left); res.append(node.val); dfs(node.right); dfs(root); return res",
        "hints": [
            "Inorder traversal visits left subtree, then root, then right subtree.",
            "You can use recursion or an iterative approach with a stack."
        ]
    },
    {
        "id": "qotd-013",
        "date": "2026-02-12",
        "title": "3Sum",
        "difficulty": "Medium",
        "problemStatement": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. The solution set must not contain duplicate triplets.",
        "sampleInput": "nums = [-1,0,1,2,-1,-4]",
        "sampleOutput": "[[-1,-1,2],[-1,0,1]]",
        "expectedOutput": "-1,-1,2;-1,0,1",
        "solution": "class Solution: def threeSum(self, nums): nums.sort(); res = []; for i in range(len(nums)-2): if i > 0 and nums[i] == nums[i-1]: continue; l, r = i+1, len(nums)-1; while l < r: s = nums[i] + nums[l] + nums[r]; if s < 0: l += 1; elif s > 0: r -= 1; else: res.append([nums[i], nums[l], nums[r]]); while l < r and nums[l] == nums[l+1]: l += 1; while l < r and nums[r] == nums[r-1]: r -= 1; l += 1; r -= 1; return res",
        "hints": [
            "Sort the array first.",
            "Use two pointers for each fixed element to find pairs that sum to the negative of that element."
        ]
    },
    {
        "id": "qotd-014",
        "date": "2026-02-13",
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "problemStatement": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
        "sampleInput": "nums1 = [1,3], nums2 = [2]",
        "sampleOutput": "2.0",
        "expectedOutput": "2.0",
        "solution": "# Binary search approach - find correct partition in both arrays",
        "hints": [
            "Use binary search on the smaller array.",
            "Find a partition where all elements on the left are smaller than all elements on the right."
        ]
    }
]